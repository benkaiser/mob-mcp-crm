import Database from 'better-sqlite3';

// ─── Types ──────────────────────────────────────────────────────

export type ReminderFrequency = 'one_time' | 'weekly' | 'monthly' | 'yearly';
export type ReminderStatus = 'active' | 'snoozed' | 'completed' | 'dismissed';

export interface Reminder {
  id: string;
  contact_id: string;
  title: string;
  description: string | null;
  reminder_date: string;
  frequency: ReminderFrequency;
  status: ReminderStatus;
  is_auto_generated: boolean;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}

export interface CreateReminderInput {
  contact_id: string;
  title: string;
  description?: string;
  reminder_date: string;
  frequency?: ReminderFrequency;
}

export interface UpdateReminderInput {
  title?: string;
  description?: string;
  reminder_date?: string;
  frequency?: ReminderFrequency;
}

export interface ListRemindersOptions {
  contact_id?: string;
  status?: ReminderStatus;
  page?: number;
  per_page?: number;
}

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  per_page: number;
}

// ─── Service ────────────────────────────────────────────────────

export class ReminderService {
  constructor(private db: Database.Database) {}

  create(input: CreateReminderInput, isAutoGenerated = false): Reminder {
    const id = crypto.randomUUID().replace(/-/g, '').substring(0, 32);
    const now = new Date().toISOString();

    this.db.prepare(`
      INSERT INTO reminders (id, contact_id, title, description, reminder_date, frequency, is_auto_generated, created_at, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(id, input.contact_id, input.title, input.description ?? null,
      input.reminder_date, input.frequency ?? 'one_time', isAutoGenerated ? 1 : 0, now, now);

    return this.getById(id)!;
  }

  get(id: string): Reminder | null {
    return this.getById(id);
  }

  update(id: string, input: UpdateReminderInput): Reminder | null {
    const existing = this.getById(id);
    if (!existing) return null;

    const fields: string[] = [];
    const values: any[] = [];

    if (input.title !== undefined) { fields.push('title = ?'); values.push(input.title); }
    if (input.description !== undefined) { fields.push('description = ?'); values.push(input.description); }
    if (input.reminder_date !== undefined) { fields.push('reminder_date = ?'); values.push(input.reminder_date); }
    if (input.frequency !== undefined) { fields.push('frequency = ?'); values.push(input.frequency); }

    if (fields.length > 0) {
      fields.push("updated_at = datetime('now')");
      values.push(id);
      this.db.prepare(`UPDATE reminders SET ${fields.join(', ')} WHERE id = ? AND deleted_at IS NULL`).run(...values);
    }

    return this.getById(id);
  }

  complete(id: string): Reminder | null {
    const existing = this.getById(id);
    if (!existing) return null;

    if (existing.frequency !== 'one_time') {
      // Advance to next occurrence
      const nextDate = this.advanceDate(existing.reminder_date, existing.frequency);
      this.db.prepare(`
        UPDATE reminders SET reminder_date = ?, status = 'active', updated_at = datetime('now')
        WHERE id = ? AND deleted_at IS NULL
      `).run(nextDate, id);
    } else {
      this.db.prepare(`
        UPDATE reminders SET status = 'completed', updated_at = datetime('now')
        WHERE id = ? AND deleted_at IS NULL
      `).run(id);
    }

    return this.getById(id);
  }

  snooze(id: string, newDate: string): Reminder | null {
    const existing = this.getById(id);
    if (!existing) return null;

    this.db.prepare(`
      UPDATE reminders SET status = 'snoozed', reminder_date = ?, updated_at = datetime('now')
      WHERE id = ? AND deleted_at IS NULL
    `).run(newDate, id);

    return this.getById(id);
  }

  dismiss(id: string): boolean {
    const result = this.db.prepare(`
      UPDATE reminders SET status = 'dismissed', updated_at = datetime('now')
      WHERE id = ? AND deleted_at IS NULL
    `).run(id);
    return result.changes > 0;
  }

  softDelete(id: string): boolean {
    const result = this.db.prepare(`
      UPDATE reminders SET deleted_at = datetime('now'), updated_at = datetime('now')
      WHERE id = ? AND deleted_at IS NULL
    `).run(id);
    return result.changes > 0;
  }

  list(options: ListRemindersOptions = {}): PaginatedResult<Reminder> {
    const page = options.page ?? 1;
    const perPage = options.per_page ?? 20;
    const offset = (page - 1) * perPage;

    const conditions: string[] = ['deleted_at IS NULL'];
    const params: any[] = [];

    if (options.contact_id) {
      conditions.push('contact_id = ?');
      params.push(options.contact_id);
    }
    if (options.status) {
      conditions.push('status = ?');
      params.push(options.status);
    }

    const whereClause = conditions.join(' AND ');

    const countResult = this.db.prepare(
      `SELECT COUNT(*) as count FROM reminders WHERE ${whereClause}`
    ).get(...params) as any;

    const rows = this.db.prepare(
      `SELECT * FROM reminders WHERE ${whereClause} ORDER BY reminder_date ASC LIMIT ? OFFSET ?`
    ).all(...params, perPage, offset) as any[];

    const data = rows.map((r) => this.mapRow(r));

    return { data, total: countResult.count, page, per_page: perPage };
  }

  /**
   * Get overdue and upcoming reminders within a time window.
   */
  getUpcoming(daysAhead = 7): Reminder[] {
    const futureDate = new Date(Date.now() + daysAhead * 86400000).toISOString().split('T')[0];

    const rows = this.db.prepare(`
      SELECT * FROM reminders
      WHERE deleted_at IS NULL AND status = 'active'
        AND reminder_date <= ?
      ORDER BY reminder_date ASC
    `).all(futureDate) as any[];

    return rows.map((r) => this.mapRow(r));
  }

  /**
   * Create an auto-generated birthday reminder for a contact.
   */
  createBirthdayReminder(contactId: string, contactName: string, birthdayDate: string): Reminder {
    return this.create({
      contact_id: contactId,
      title: `${contactName}'s birthday`,
      reminder_date: birthdayDate,
      frequency: 'yearly',
    }, true);
  }

  /**
   * Remove auto-generated reminders for a contact.
   */
  removeAutoReminders(contactId: string): number {
    const result = this.db.prepare(`
      UPDATE reminders SET deleted_at = datetime('now'), updated_at = datetime('now')
      WHERE contact_id = ? AND is_auto_generated = 1 AND deleted_at IS NULL
    `).run(contactId);
    return result.changes;
  }

  private getById(id: string): Reminder | null {
    const row = this.db.prepare(
      'SELECT * FROM reminders WHERE id = ? AND deleted_at IS NULL'
    ).get(id) as any;
    if (!row) return null;
    return this.mapRow(row);
  }

  private mapRow(row: any): Reminder {
    return {
      ...row,
      is_auto_generated: Boolean(row.is_auto_generated),
    };
  }

  private advanceDate(dateStr: string, frequency: ReminderFrequency): string {
    const date = new Date(dateStr + 'T00:00:00Z');
    switch (frequency) {
      case 'weekly':
        date.setDate(date.getDate() + 7);
        break;
      case 'monthly':
        date.setMonth(date.getMonth() + 1);
        break;
      case 'yearly':
        date.setFullYear(date.getFullYear() + 1);
        break;
      default:
        break;
    }
    return date.toISOString().split('T')[0];
  }
}
